== Usage Examples ==

Avalanche comes with some simple examples. Their sources are located in 
[http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/ samples/simple] folder. It also contains [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/seed seed] file - it is initial input file for the examples. It contains just four zero bytes.

{{{
user@machine:$ hexdump samples/simple/seed 
0000000 0000 0000                              
0000004
}}}

== If input data comes from file ==

For programs that receive their input data from files just specify the name of the file with '--filename' option. [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/sample2.c sample2.c] is a small program that terminates if and only if it reads the letters 'b', 'a', 'd', '!' from input file. This is how avalanche may be used to detect the crash and generate input file that reproduces it.

{{{
user@machine:$ ./inst/bin/avalanche --filename=samples/simple/seed samples/simple/sample2 samples/simple/seed 
}}}

Avalanche generates exploit file exploit_0_0

{{{
user@machine:$ cat exploit_0_0 
bad!
}}}

Check that file causes the sample program to crash:

{{{
user@machine:$ samples/simple/sample2 exploit_0_0 
Aborted
}}}

=== If input data comes from TCP socket ===

For programs that receive their input data from TCP sockets provide host and port of server with '--host' and '--port' options. You should also specify '--sockets' option. Analysis also requires the server to be running.

[http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/writeserver.c writeserver.c] - is a simple server for [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/multiple_client.c multiple_client.c], [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/multiple_client2.c multiple_client2.c] and [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/divclient.c divclient.c] samples. It accepts any incoming connection, writes four bytes into it and closes the connection.

So, run the server first:

{{{
user@machine:$ samples/simple/writeserver &
[1] 7831
}}}

Then start the analysis:

{{{
user@machine:$ ./inst/bin/avalanche --sockets --host=127.0.0.1 --port=10000 samples/simple/multiple_client
}}}

Avalanche generates exploit_0 file. To reproduce the actual crash, use covgrind plugin:

{{{
user@machine:$ ./inst/bin/valgrind --tool=covgrind --host=127.0.0.1 --port=10000 --replace=exploit_0 --sockets=yes samples/simple/multiple_client
==7911== Covgrind-1.0, IR basic blocks addresses dumper.
==7911== Copyright (C) iisaev
==7911== Using LibVEX rev 3, a library for dynamic binary translation.
==7911== Copyright (C) 2004-2008, and GNU GPL'd, by OpenWorks LLP.
==7911== Using valgrind-3.5.0.SVN, a dynamic binary instrumentation framework.
==7911== Copyright (C) 2000-2008, and GNU GPL'd, by Julian Seward et al.
==7911== For more details, rerun with: -v
==7911== 
caught connect arg0=3 arg1=beea078c arg2=10
caught connect arg0=4 arg1=beea078c arg2=10
caught connect arg0=5 arg1=beea078c arg2=10
caught connect arg0=6 arg1=beea078c arg2=10
caught read from socket, cursocket=0 curoffs=0
caught read from socket, cursocket=1 curoffs=0
caught read from socket, cursocket=2 curoffs=0
caught read from socket, cursocket=3 curoffs=0
==7911== 
Aborted
}}}

=== To detect an error that doesn't cause a crash ===

Use '--use-memcheck' option. This will cause Avalanche to use memcheck instead of covgrind, which slows down the analysis, but allows non-critical bugs to be detected. [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/mleak.c mleak.c] sample introduces the simplest memory leak defect. Run the Avalanche as follows:

{{{
user@machine:$ ./inst/bin/avalanche --use-memcheck --leaks --filename=samples/simple/seed samples/simple/mleak samples/simple/seed 
}}}

Avalanche generates memcheck_0_0 file. To reproduce the bug, run the memcheck plugin:

{{{
user@machine:$ ./inst/bin/valgrind --tool=memcheck samples/simple/mleak memcheck_0_0 
==8371== Memcheck, a memory error detector.
==8371== Copyright (C) 2002-2008, and GNU GPL'd, by Julian Seward et al.
==8371== Using LibVEX rev 3, a library for dynamic binary translation.
==8371== Copyright (C) 2004-2008, and GNU GPL'd, by OpenWorks LLP.
==8371== Using valgrind-3.5.0.SVN, a dynamic binary instrumentation framework.
==8371== Copyright (C) 2000-2008, and GNU GPL'd, by Julian Seward et al.
==8371== For more details, rerun with: -v
==8371== 
==8371== 
==8371== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 16 from 1)
==8371== malloc/free: in use at exit: 4 bytes in 1 blocks.
==8371== malloc/free: 1 allocs, 0 frees, 4 bytes allocated.
==8371== For counts of detected errors, rerun with: -v
==8371== searching for pointers to 1 not-freed blocks.
==8371== checked 51,420 bytes.
==8371== 
==8371== LEAK SUMMARY:
==8371==    definitely lost: 4 bytes in 1 blocks.
==8371==      possibly lost: 0 bytes in 0 blocks.
==8371==    still reachable: 0 bytes in 0 blocks.
==8371==         suppressed: 0 bytes in 0 blocks.
==8371== Rerun with --leak-check=full to see details of leaked memory.
}}}

== To carry out separate analysis ==

*Warning! The features described below are under development and may not work 100%! The sources may be downloaded from [http://code.google.com/p/avalanche/source/browse/#svn/branches/separate-analysis a separate branch of repository].*

Normally Avalanche treats the whole input file as a source of tainted data and keeps track of all dangerous operations and conditions which work with tainted data. However, there are options that can be used to narrow the analysis performed by Avalanche.
[http://code.google.com/p/avalanche/source/browse/branches/separate-analysis/samples/simple/separate_analysis_sample.c separate_analysis_sample.c] shows effects of employing these options.
This sample is a small program, that reads 4 bytes from input file and uses each value in if statement. It fails only if value in the last byte doesn't satisfy the appropriate condition.

Run Avalanche without any additional options:

{{{
user@machine:$ ./inst/bin/avalanche --filename=samples/simple/seed samples/simple/separate_analysis_sample samples/simple/seed 
}}}

This results in 8 exploit files (exploit_0_0 .. exploit_7_0). Checking these files with gdb shows that they all trigger the same error:

{{{
user@machine:$ gdb --args ./samples/simple/separate_analysis_sample exploit_0_0
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) run
Starting program: /samples/simple/separate_analysis_sample exploit_0_0

Program received signal SIGSEGV, Segmentation fault.
0x08048501 in main (argc=536870912, argv=0x5bf)
    at separate_analysis_sample.c:56
56	  *d = 1;
}}}

=== Using input mask ===

*Warning! The features described below are under development and may not work 100%! The sources may be downloaded from [http://code.google.com/p/avalanche/source/browse/#svn/branches/separate-analysis a separate branch of repository].*

To specify that some bytes in input file should not be considered as a source of tainted data, use "--input-filter-file=name" option, where name is the name of the file with input mask. Input mask contains ranges or single offsets of bytes that should not be considered as a source of tainted data.

File 'mask' contains the following:

{{{
0-2
}}}

Running Avalanche with options:

{{{
user@machine:$ ./inst/bin/avalanche --input-filter-file=mask --filename=samples/simple/seed samples/simple/separate_analysis_sample samples/simple/seed 
}}}

will result in exploit_0_0 (since only the condition for the last byte actually leads to error). This exploit file triggers error described above.

Running Avalanche on large applications with appropriate input masks featured considerable decrease in time needed to discover bugs.

=== Using function filtering ===

*Warning! The features described below are under development and may not work 100%! The sources may be downloaded from [http://code.google.com/p/avalanche/source/browse/#svn/branches/separate-analysis a separate branch of repository].*

To specify that danger operations and conditions working with tainted data only from necessary functions are used in generating new inputs, use "--func-filter=type" with "--func-name=name" options. type can be either 'conds' (so that only conditions will be filtered while all danger operations are used in generating new inputs) or 'danger_ops' (vice-versa) or 'all' (so that both conditions and danger operations are filtered). name is the name of the function to use for filtering (you can specify several "--func-name=name" arguments).

Running Avalanche with options:

{{{
user@machine:$ ./inst/bin/avalanche --func-filter=conds --func-name=f4 filename=samples/simple/seed samples/simple/separate_analysis_sample samples/simple/seed 
}}}

will result in exploit_0_0 (refer to [http://code.google.com/p/avalanche/source/browse/branches/separate-analysis/samples/simple/separate_analysis_sample.c separate_analysis_sample.c] code for understanding reasons for this). This exploit file triggers error described above.

As with input masks running Avalanche with appropriate list of functions featured decrease in time needed to perform analysis.