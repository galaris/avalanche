== Usage Examples ==

Avalanche comes with some simple examples. Their sources are located in 
[http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/ samples/simple] folder. It also contains [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/seed seed] file - it is initial input file for the examples. It contains just four zero bytes.

{{{
user@machine:$ hexdump samples/simple/seed 
0000000 0000 0000                              
0000004
}}}

== If input data comes from file ==

For programs that receive their input data from files just specify the name of the file with '--filename' option. [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/sample2.c sample2.c] is a small program that terminates if and only if it reads the letters 'b', 'a', 'd', '!' from input file. This is how avalanche may be used to detect the crash and generate input file that reproduces it.

{{{
user@machine:$ ./inst/bin/avalanche --filename=samples/simple/seed samples/simple/sample2 samples/simple/seed 
}}}

Avalanche generates exploit file exploit_0_0

{{{
user@machine:$ cat exploit_0_0 
bad!
}}}

Check that file causes the sample program to crash:

{{{
user@machine:$ samples/simple/sample2 exploit_0_0 
Aborted
}}}

=== If input data comes from TCP socket ===

For programs that receive their input data from TCP sockets provide host and port of server with '--host' and '--port' options. You should also specify '--sockets' option. Analysis also requires the server to be running.

[http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/writeserver.c writeserver.c] - is a simple server for [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/multiple_client.c multiple_client.c], [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/multiple_client2.c multiple_client2.c] and [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/divclient.c divclient.c] samples. It accepts any incoming connection, writes four bytes into it and closes the connection.

So, run the server first:

{{{
user@machine:$ samples/simple/writeserver &
[1] 7831
}}}

Then start the analysis:

{{{
user@machine:$ ./inst/bin/avalanche --sockets --host=127.0.0.1 --port=10000 samples/simple/multiple_client
}}}

Avalanche generates exploit_0 file. To reproduce the actual crash, use covgrind plugin:

{{{
user@machine:$ ./inst/bin/valgrind --tool=covgrind --host=127.0.0.1 --port=10000 --replace=exploit_0 --sockets=yes samples/simple/multiple_client
==7911== Covgrind-1.0, IR basic blocks addresses dumper.
==7911== Copyright (C) iisaev
==7911== Using LibVEX rev 3, a library for dynamic binary translation.
==7911== Copyright (C) 2004-2008, and GNU GPL'd, by OpenWorks LLP.
==7911== Using valgrind-3.5.0.SVN, a dynamic binary instrumentation framework.
==7911== Copyright (C) 2000-2008, and GNU GPL'd, by Julian Seward et al.
==7911== For more details, rerun with: -v
==7911== 
caught connect arg0=3 arg1=beea078c arg2=10
caught connect arg0=4 arg1=beea078c arg2=10
caught connect arg0=5 arg1=beea078c arg2=10
caught connect arg0=6 arg1=beea078c arg2=10
caught read from socket, cursocket=0 curoffs=0
caught read from socket, cursocket=1 curoffs=0
caught read from socket, cursocket=2 curoffs=0
caught read from socket, cursocket=3 curoffs=0
==7911== 
Aborted
}}}

=== To detect an error that doesn't cause a crash ===

Use '--use-memcheck' option. This will cause Avalanche to use memcheck instead of covgrind, which slows down the analysis, but allows non-critical bugs to be detected. [http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/mleak.c mleak.c] sample introduces the simplest memory leak defect. Run the Avalanche as follows:

{{{
user@machine:$ ./inst/bin/avalanche --use-memcheck --leaks --filename=samples/simple/seed samples/simple/mleak samples/simple/seed 
}}}

Avalanche generates memcheck_0_0 file. To reproduce the bug, run the memcheck plugin:

{{{
user@machine:$ ./inst/bin/valgrind --tool=memcheck samples/simple/mleak memcheck_0_0 
==8371== Memcheck, a memory error detector.
==8371== Copyright (C) 2002-2008, and GNU GPL'd, by Julian Seward et al.
==8371== Using LibVEX rev 3, a library for dynamic binary translation.
==8371== Copyright (C) 2004-2008, and GNU GPL'd, by OpenWorks LLP.
==8371== Using valgrind-3.5.0.SVN, a dynamic binary instrumentation framework.
==8371== Copyright (C) 2000-2008, and GNU GPL'd, by Julian Seward et al.
==8371== For more details, rerun with: -v
==8371== 
==8371== 
==8371== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 16 from 1)
==8371== malloc/free: in use at exit: 4 bytes in 1 blocks.
==8371== malloc/free: 1 allocs, 0 frees, 4 bytes allocated.
==8371== For counts of detected errors, rerun with: -v
==8371== searching for pointers to 1 not-freed blocks.
==8371== checked 51,420 bytes.
==8371== 
==8371== LEAK SUMMARY:
==8371==    definitely lost: 4 bytes in 1 blocks.
==8371==      possibly lost: 0 bytes in 0 blocks.
==8371==    still reachable: 0 bytes in 0 blocks.
==8371==         suppressed: 0 bytes in 0 blocks.
==8371== Rerun with --leak-check=full to see details of leaked memory.
}}}

== Input masks and function filtering ==

*Warning! The features described below are under development and may not work 100%! The sources may be downloaded from SVN trunk:*

{{{
$ svn checkout http://avalanche.googlecode.com/svn/trunk avalanche
}}}

Normally Avalanche treats the whole input file as a source of tainted data and keeps track of all dangerous operations and conditions which work with tainted data. In this case the analysis may not be effective, because it takes too much time to get to deep and usually the most interesting parts of the application. There are several ways to overcome this limitation and let Avalanche analyze specific parts of the application.

The most effective way is specifying a mask for application input. Such a mask is a file containing a list of tainted positions, e. g. the numbers of only bytes in the input that should be considered as containing tainted values. If such a mask is specified, then Avalanche changes only those bytes in the application input which positions are listed in the mask, while all the rest bytes remain the same in all the new inputs generated by Avalanche on every iteration.

The mask may be specified with '--mask=<mask_file>' option.

Our measurements show that using mask is a very effective. It allows Avalanche to discover many new defects that had been impossible to detect before this feature was introduced.

A small sample for using masks: [http://code.google.com/p/avalanche/source/browse/branches/separate-analysis/samples/simple/separate_analysis_sample.c separate_analysis_sample.c]

Let mask contain the only position:

{{{
3
}}}

Then the analysis may be run like that:

{{{
user@machine:$ ./inst/bin/avalanche --mask=mask --filename=samples/simple/seed samples/simple/separate_analysis_sample samples/simple/seed 
}}}

It generates 'exploit_0_0' file, which causes a program crash since 'd' is used uninitialized:

{{{
user@machine:$ gdb --args ./samples/simple/separate_analysis_sample exploit_0_0
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) run
Starting program: /samples/simple/separate_analysis_sample exploit_0_0

Program received signal SIGSEGV, Segmentation fault.
0x08048501 in main (argc=536870912, argv=0x5bf)
    at separate_analysis_sample.c:56
56	  *d = 1;
}}}

Another way is separate function analysis. Avalanche may analyze only specific functions instead of analyzing complete application at once.

First, run Avalanche with '--dump-calls' option. If this option is specified Avalanche runs a single iteration and dumps the file calldump.log which contains a list of all functions of the application that manipulated tainted data during that run.

Running Avalanche with that option on the above sample ([http://code.google.com/p/avalanche/source/browse/branches/separate-analysis/samples/simple/separate_analysis_sample.c separate_analysis_sample.c])

{{{
user@machine:$ ./inst/bin/avalanche --dump-calls --filename=samples/simple/seed  samples/simple/separate_analysis_sample samples/simple/seed
}}}

generates calldump.log

{{{
f1
f2
f3
f4
}}}

To specify specific function(s) for the analysis one may use either the '--func-name=<name>' option (it may be used multiple times) or '--func-filter-file=<file>' option to read a list of function names from the corresponding file.

For example:

{{{
user@machine:$ ./inst/bin/avalanche --func-name=f4 --filename=samples/simple/seed  samples/simple/separate_analysis_sample samples/simple/seed
}}}

This will result in generation of exploit_0_0 file. Obviously, if any other function name is specified (f1, f2 or f3), no exploits are found, because the condition that should be alternated by Avalanche to detect a bug is located in f4 function.

There is also '--suppress-subcalls' option, which may be used together with '--func-name' and '--func-filter-file' options. If it is not specified, then Avalanche tries to alternate all the conditions between entry and exit points of the specified function(s). Obviously, some of these conditions may be located inside a nested function calls. To exclude these conditions from the analysis, specify the '--suppress-subcalls' option.