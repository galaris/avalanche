=== Using Avalanche ===

=== Synopsis ===
avalanche _avalanche-options_ _program_ _program-options_

This command will iteratively run the _program_ with specified command line _program-options_ under Avalanche. The program's executable (binary) code will be dynamically instrumented and analysed by Avalanche to detect errors, and generate inputs for the next iteration.

=== Avalanche options ===

|| *flag name* || *default* || *description* ||
|| *Avalanche general options* || || ||
||--help|| ||Print help and exit||
||--verbose|| ||Much more detailed avalanche output||
||--debug|| ||Save some debugging information - divergent inputs, etc.||
||--check-danger|| ||Emit special constraints for memory access operations and divisions||
||--trace-children|| ||Run valgrind plugins with '--trace-children=yes' option||
|| --depth=number ||100||The number of conditions inverted during one run of tracegrind||
||--use-memcheck|| ||Indicate that memcheck should be used instead of covgrind||
||--leaks|| ||Indicate that inputs resulting in memory leaks should be saved (ignored if '--use-memcheck' isn't specified)||
|| *if the program receives input data from files* || || ||
|| --filename=input_file || ||The path to the file with the input data for the analyzed program (may be used multiple times)||
|| --alarm=number ||300||Timer value in seconds (for infinite loop recognition). If the execution runs for the specified number of seconds, then Avalanche suspects an infinite loop in the program and dumps the corresponding input file as exploit||
|| *if the program receives input data from sockets* || || ||
||--sockets|| ||Mark data read from TCP sockets as tainted||
||--datagrams|| ||Mark data read from UDP sockets as tainted||
|| --host=IPv4 address ||not set||IP address of the network connection (for TCP sockets only)||
|| --port=number ||not set||Port number of the network connection (for TCP sockets only)||
|| --alarm=number ||not set||Timer for breaking infinite waitings in covgrind or memcheck. It designates the maximum time for each run of covgrind or memcheck. If the timer expires, the plugin is killed. Set this option if the analysed program "hangs" on some iteration.||
|| --tracegrind-alarm=number ||not set||Timer for breaking infinite waitings in tracegrind. It designates the maximum time for each run of tracegrind. If the timer expires, the plugin is killed. Set this option if the analysed program "hangs" on some iteration. In general, this value should be greater than the timer for covgrind or memcheck specified by '--alarm' option.||
|| *[http://code.google.com/p/avalanche/wiki/Input_masks_and_function_filtering masks and separate function analysis]* || || ||
|| --mask=mask_file || ||The path to the [http://code.google.com/p/avalanche/wiki/Mask_syntax mask file]||
|| --dump-calls || ||Dump the list of functions manipulating with tainted data to calldump.log||
|| --func-name=name || ||The name of function that should be used for separate function analysis (may be used multiple times)||
|| --func-file=name || ||The path to the file with the list of functions that should be used for separate function analysis||
|| --suppress-subcalls || ||Ignore conditions in a nested function calls during separate analysis||

=== Avalanche output ===

If input data is received from file and avalanche finds a crash, then it dumps a file with the name 'exploit_i_j' where 'j' is the number of the file (multiple input files may be specified with '--filename' option) and 'i' is the number of the exploit. If the input file is single, then the generated "inputs of death" have names 'exploit_0_0', 'exploit_1_0', 'exploit_2_0' and so on. If the generated file doesn't cause a crash, but still demonstrates an error in the program (i. e. the bug is found by memcheck), then it has the name 'memcheck_i_j'.

If input data is received from socket, then the generated files have the names 'exploit_i' and/or 'memcheck_i' where 'i' is the number of detected defect. See [Samples] wiki page for some examples.