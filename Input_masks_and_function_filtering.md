Normally Avalanche treats the whole input file as a source of tainted data and keeps track of all dangerous operations and conditions which work with tainted data. In this case the analysis may not be effective, because it takes too much time to get to deep and usually the most interesting parts of the application. There are several ways to overcome this limitation and let Avalanche analyze specific parts of the application.

### Input masks ###

The most effective way is specifying a mask for application input. Such a mask is a file containing a list of tainted positions, e. g. the numbers of only bytes in the input that should be considered as containing tainted values. If such a mask is specified, then Avalanche changes only those bytes in the application input which positions are listed in the mask, while all the rest bytes remain the same in all the new inputs generated by Avalanche on every iteration.

The mask may be specified with '--mask=mask\_file' option.

Our measurements show that using mask is a very effective. It allows Avalanche to discover many new defects that had been impossible to detect before this feature was introduced.

A small sample for using masks: [separate\_analysis\_sample.c](http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/separate_analysis_sample.c)

Let mask contain the only position:

```
3
```

Then the analysis may be run like that:

```
user@machine:$ ./inst/bin/avalanche --mask=mask --filename=samples/simple/seed samples/simple/separate_analysis_sample samples/simple/seed 
```

It generates 'exploit\_0\_0' file, which causes a program crash since 'd' is used uninitialized:

```
user@machine:$ gdb --args ./samples/simple/separate_analysis_sample exploit_0_0
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) run
Starting program: /samples/simple/separate_analysis_sample exploit_0_0

Program received signal SIGSEGV, Segmentation fault.
0x08048501 in main (argc=536870912, argv=0x5bf)
    at separate_analysis_sample.c:56
56	  *d = 1;
```

The syntax and samples of masks definition is described in [Mask\_syntax](Mask_syntax.md)

### Function filtering ###

Another way is separate function analysis. Avalanche may analyze only specific functions instead of analyzing complete application at once.

First, run Avalanche with '--dump-calls' option. If this option is specified Avalanche runs a single iteration and dumps the file calldump.log which contains a list of all functions of the application that manipulated tainted data during that run.

Running Avalanche with that option on the above sample ([separate\_analysis\_sample.c](http://code.google.com/p/avalanche/source/browse/trunk/samples/simple/separate_analysis_sample.c))

```
user@machine:$ ./inst/bin/avalanche --dump-calls --filename=samples/simple/seed  samples/simple/separate_analysis_sample samples/simple/seed
```

generates calldump.log

```
f1
f2
f3
f4
```

To specify specific function(s) for the analysis one may use either the '--func-name=name' option (it may be used multiple times) or '--func-file=file' option to read a list of function names from the corresponding file (see [this page](Specifying_functions_for_separate_analysis.md) for more specific instructions on list creation).

For example:

```
user@machine:$ ./inst/bin/avalanche --func-name=f4 --filename=samples/simple/seed  samples/simple/separate_analysis_sample samples/simple/seed
```

This will result in generation of exploit\_0\_0 file. Obviously, if any other function name is specified (f1, f2 or f3), no exploits are found, because the condition that should be alternated by Avalanche to detect a bug is located in f4 function.

There is also '--suppress-subcalls' option, which may be used together with '--func-name' and '--func-file' options. If it is not specified, then Avalanche tries to alternate all the conditions between entry and exit points of the specified function(s). Obviously, some of these conditions may be located inside a nested function calls. To exclude these conditions from the analysis, specify the '--suppress-subcalls' option.

Separate function analysis tends to be less effective than using masks because the traces and corresponding STP queries may be very long in the case of separate analysis, and checking the satisfiability of these queries may take a considerable amount of time.